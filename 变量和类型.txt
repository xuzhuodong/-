二、为什么区分原始类型和对象类型
    2.1 不可变性
    上面所提到的原始类型，在ECMAScript标准中，
        它们被定义为primitive values，即原始值，代表值本身是不可被改变的。
    以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的：
        var str = 'ConardLi';
        str.slice(1);
        str.substr(1);
        str.trim(1);
        str.toLowerCase(1);
        str[0] = 1;
        console.log(str);  // ConardLi
    在上面的代码中我们对str调用了几个方法，无一例外，
        这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变str，这就印证了字符串的不可变性。
    那么，当我们继续调用下面的代码：
        str += '6'
        console.log(str);  // ConardLi6
    你会发现，str的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：

=============
以数组为例，它的很多方法都可以改变它自身。
    pop() 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素
    shift()把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值
    push()向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度
    
    unshift()向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度
    reverse()颠倒数组中元素的顺序，改变原数组，返回该数组
    sort()对数组元素进行排序，改变原数组，返回该数组
    splice()从数组中添加/删除项目，改变原数组，返回被删除的元素
2.1 不可变性=============
    堆内存：
    存储的值大小不定，可动态调整
    空间较大，运行效率低
    无法直接操作其内部存储，使用引用地址读取
    通过代码进行分配空间
2.2引用用类型======================
    栈内存：
    存储的值大小固定
    空间较小
    可以直接操作其保存的变量，运行效率高
    由系统自动分配存储空间
2.3 复制======================
    当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，
    所以复制出来的obj2实际上和obj指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，
    另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。
2.4比较====================
    对于原始类型，比较时会直接比较它们的值，如果值相等，即返回true。
    对于引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，
        但是它们被存储在了不同的存储空间，因此比较值为false。
2.5 值传递和引用传递=========================
    借助下面的例子，我们先来看一看什么是值传递，什么是引用传递：
        let name = 'ConardLi';
        function changeValue(name){
          name = 'code秘密花园';
        }
        changeValue(name);
        console.log(name);
    执行上面的代码，如果最终打印出来的name是'ConardLi'，没有改变，
    说明函数参数传递的是变量的值，即值传递。如果最终打印的是'code秘密花园'，
    函数内部的操作可以改变传入的变量，那么说明函数参数传递的是引用，即引用传递。

    很明显，上面的执行结果是'ConardLi'，即函数参数仅仅是被传入变量复制给了的一个局部变量，
    改变这个局部变量不会对外部变量产生影响。
        let obj = {name:'ConardLi'};
        function changeValue(obj){
          obj.name = 'code秘密花园';
        }
        changeValue(obj);
        console.log(obj.name); // code秘密花园
    上面的代码可能让你产生疑惑，是不是参数是引用类型就是引用传递呢？
    首先明确一点，ECMAScript中所有的函数的参数都是按值传递的。
    同样的，当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，
    只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，
    实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，下面我们再按一个例子：
        let obj = {};
        function changeValue(obj){
          obj.name = 'ConardLi';
          obj = {name:'code秘密花园'};
        }
        changeValue(obj);
        console.log(obj.name); // ConardLi
    可见，函数参数传递的并不是变量的引用，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，
        当变量是引用类型时，这个副本是指向堆内存的地址。所以，再次记住：
    ECMAScript中所有的函数的参数都是按值传递的。
为什么0.1+0.2不等于0.3？=====================
    0.1的二进制：
        0.0001100110011001100110011001100110011001100110011001101
    0.2的二进制：
        0.001100110011001100110011001100110011001100110011001101
    理论上讲，由上面的结果相加应该：：
        0.0100110011001100110011001100110011001100110011001100111
    实际JS计算得到的0.1+0.2的二进制
        0.0100110011001100110011001100110011001100110011001101
    ---------------------
    为什么 js计算出的 0.1的二进制 是这么多位而不是更多位？？？
    为什么 js计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？
    为什么 0.1的二进制 + 0.2的二进制 != 0.3的二进制？？？
5.3 js对二进制小数的存储方式======================
    小数的二进制大多数都是无限循环的，JavaScript是怎么来存储他们的呢？
    在ECMAScript®语言规范中可以看到，ECMAScript中的Number类型遵循IEEE 754标准。使用64位固定长度来表示。
    事实上有很多语言的数字类型都遵循这个标准，例如JAVA,所以很多语言同样有着上面同样的问题。
    所以下次遇到这种问题不要上来就喷JavaScript…
    有兴趣可以看看下这个网站http://0.30000000000000004.com/，
        是的，你没看错，就是http://0.30000000000000004.com/！！！
5.5 js中的toString(2)============================
    由于尾数位只能存储52个数字，这就能解释toString(2)的执行结果了：
    如果计算机没有存储空间的限制，那么0.1的二进制应该是：
    0.00011001100110011001100110011001100110011001100110011001...
    科学计数法尾数位
    1.1001100110011001100110011001100110011001100110011001...
    但是由于限制，有效数字第53位及以后的数字是不能存储的，它遵循，如果是1就向前一位进1，如果是0就舍弃的原则。
    0.1的二进制科学计数法第53位是1，所以就有了下面的结果：
    0.0001100110011001100110011001100110011001100110011001101

    0.2有着同样的问题，其实正是由于这样的存储，在这里有了精度丢失，导致了0.1+0.2!=0.3。
5.6 JavaScript能表示的最大数字====================
    由与IEEE 754双精度64位规范的限制：
    指数位能表示的最大数字：1023(十进制)
    尾数位能表达的最大数字即尾数位都位1的情况
    所以JavaScript能表示的最大数字即位
    1.111...X 21023 这个结果转换成十进制是1.7976931348623157e+308,
        这个结果即为Number.MAX_VALUE。
=================